---
ID: 7
post_title: Exploiting Buffer
author: wpengine
post_date: 2016-04-05 00:00:00
post_excerpt: ""
layout: post
permalink: http://snyk.wpengine.com/?p=7
published: true
---
<p>Hidden between the wonders of Node lies a ticking bomb by the name of Buffer. If handled incorrectly, this risky class can easily leak server side memory, and with it your secrets and keys. Good and popular projects have tripped over this wire, including npm packages <a href="https://snyk.io/vuln/npm:mongoose:20160116">mongoose</a>,  <a href="https://snyk.io/vuln/npm:ws:20160104">ws</a>, <a href="https://snyk.io/vuln/npm:request:20160119">request</a> and most recently <a href="https://snyk.io/vuln/npm:sequelize:20160115">sequelize</a> introducing wide-spread vulnerabilities.</p>

<p>In this post, we’ll explain how Buffer works, and why does it behave the way it does. We’ll run an exploit against a vulnerable application, to better demonstrate the ramifications. Lastly, we’ll discuss what changes to expect in Node 6, and <a href="#steps-to-stay-safe">list 5 steps</a> you can take to protect yourself from <code class="highlighter-rouge">Buffer</code>’s default behavior, and</p>

<h2 id="how-did-we-get-here">How did we get here</h2>
<p>Client-side JavaScript spares us the need to deal with memory allocation. Like many of its peer languages, in JS the underlying engine (e.g. V8) allocates memory and garbage-collects it as needed, making coding simpler and safer. In the browser, preventing access to memory is also necessary to maintain the sandbox JS runs in.</p>

<p>When JS expanded to the server with Node, the browser sandbox was removed, and the need for easy and fast binary data processing increased. To address these needs, Node introduced the Buffer class, which deals with binary data. Note that ES6 later created additional binary oriented classes, notably <code class="highlighter-rouge">TypedArray</code> and <code class="highlighter-rouge">ArrayBuffer</code>.</p>

<p>Buffer is a mutable array of binary data, and can be initialized with a string, array or number. Some excerpts from the node.js documentation:</p>

<div class="highlighter-rouge"><div class="syntax"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span style="color: #66d9ef">const</span> <span style="color: #ffffff">buf1</span> <span style="color: #f92672">=</span> <span style="color: #f92672">new</span> <span style="color: #ffffff">Buffer</span><span style="color: #ffffff">([</span><span style="color: #ae81ff">1</span><span style="color: #ffffff">,</span><span style="color: #ae81ff">2</span><span style="color: #ffffff">,</span><span style="color: #ae81ff">3</span><span style="color: #ffffff">]);</span>
<span style="color: #75715e">// creates a buffer containing [01, 02, 03]</span>
<span style="color: #66d9ef">const</span> <span style="color: #ffffff">buf2</span> <span style="color: #f92672">=</span> <span style="color: #f92672">new</span> <span style="color: #ffffff">Buffer</span><span style="color: #ffffff">(</span><span style="color: #e6db74">'test'</span><span style="color: #ffffff">);</span>   
<span style="color: #75715e">// creates a buffer containing ASCII bytes [74, 65, 73, 74]</span>
<span style="color: #66d9ef">const</span> <span style="color: #ffffff">buf3</span> <span style="color: #f92672">=</span> <span style="color: #f92672">new</span> <span style="color: #ffffff">Buffer</span><span style="color: #ffffff">(</span><span style="color: #ae81ff">10</span><span style="color: #ffffff">);</span>
<span style="color: #75715e">// creates a buffer of length 10  </span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The first two variants simply create a binary representation of the value it received. The last one, however, pre-allocates a buffer of the specified size, making it a useful, well, buffer, especially when reading data from a stream.</p>

<h2 id="the-security-flaw">The Security Flaw</h2>
<p>When using the <code class="highlighter-rouge">number</code> constructor of <code class="highlighter-rouge">Buffer</code>, it will allocate the memory, but will not fill it with zeros. Instead, the allocated buffer holds… whatever was in memory at the time.</p>

<p>You can see this behaviour yourself by running Node in a terminal and repeatedly creating a Buffer of a given size, and seeing each one holds different values, as it points to some other portion of previously used memory.</p>

<div class="highlighter-rouge"><div class="syntax"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span style="color: #f92672">></span> <span style="color: #f92672">new</span> <span style="color: #ffffff">Buffer</span><span style="color: #ffffff">(</span><span style="color: #ae81ff">10</span><span style="color: #ffffff">)</span>
<span style="color: #f92672"><</span><span style="color: #ffffff">Buffer</span> <span style="color: #ae81ff">00</span> <span style="color: #ae81ff">20</span> <span style="color: #ae81ff">00</span> <span style="color: #ae81ff">00</span> <span style="color: #ae81ff">00</span> <span style="color: #ae81ff">00</span> <span style="color: #ae81ff">00</span> <span style="color: #ae81ff">00</span> <span style="color: #ffffff">d0</span> <span style="color: #ae81ff">4</span><span style="color: #ffffff">d</span><span style="color: #f92672">></span>
<span style="color: #f92672">></span> <span style="color: #f92672">new</span> <span style="color: #ffffff">Buffer</span><span style="color: #ffffff">(</span><span style="color: #ae81ff">10</span><span style="color: #ffffff">)</span>
<span style="color: #f92672"><</span><span style="color: #ffffff">Buffer</span> <span style="color: #ae81ff">50</span> <span style="color: #ae81ff">74</span> <span style="color: #ae81ff">84</span> <span style="color: #ae81ff">02</span> <span style="color: #ae81ff">01</span> <span style="color: #ae81ff">00</span> <span style="color: #ae81ff">00</span> <span style="color: #ae81ff">00</span> <span style="color: #ae81ff">0</span><span style="color: #ffffff">a</span> <span style="color: #ae81ff">00</span><span style="color: #f92672">></span>
<span style="color: #f92672">></span> <span style="color: #f92672">new</span> <span style="color: #ffffff">Buffer</span><span style="color: #ffffff">(</span><span style="color: #ae81ff">10</span><span style="color: #ffffff">)</span>
<span style="color: #f92672"><</span><span style="color: #ffffff">Buffer</span> <span style="color: #ae81ff">78</span> <span style="color: #ae81ff">74</span> <span style="color: #ae81ff">84</span> <span style="color: #ae81ff">02</span> <span style="color: #ae81ff">01</span> <span style="color: #ae81ff">00</span> <span style="color: #ae81ff">00</span> <span style="color: #ae81ff">00</span> <span style="color: #ae81ff">05</span> <span style="color: #ae81ff">00</span><span style="color: #f92672">></span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>This is a <a href="https://nodejs.org/api/buffer.html#buffer_new_buffer_size">well documented behaviour</a>, and you can zero the allocated memory simply by calling “<a href="https://nodejs.org/api/buffer.html#buffer_buf_fill_value_offset_end_encoding">buf.fill(0)</a>”. However, if you forget to zero it, you may find yourself leaking memory. Exposing memory doesn’t sound that bad until you consider the number of secrets – keys, source code, system info – that could be exposed. <a href="http://heartbleed.com/">Heartbleed</a>, the massive 2014 OpenSSL vulnerability, was a memory exposure vulnerability.</p>

<h2 id="demonstrating-the-security-risk">Demonstrating The Security Risk</h2>
<p>To better understand the Buffer vulnerability, lets look at a vulnerable application called <a href="https://github.com/snyk/goof">Goof</a>. Its code is <a href="https://github.com/snyk/goof">hosted on GitHub</a>, along with installation instructions if you want to run these exploits yourself.</p>

<p class="u--centered">
<img src="https://res.cloudinary.com/snyk/image/upload/v1458651899/blog-exploiting-buffer-todo-base.png" alt="" />
</p>

<p>This is a simple (vulnerable) TODO list app. It uses <a href="https://www.npmjs.com/package/mongoose">mongoose</a> to communicate with the MongoDB where the items are stored, using a simple schema:</p>

<div class="highlighter-rouge"><div class="syntax"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span style="color: #66d9ef">var</span> <span style="color: #ffffff">Todo</span> <span style="color: #f92672">=</span> <span style="color: #f92672">new</span> <span style="color: #ffffff">Schema</span><span style="color: #ffffff">({</span>
  <span style="color: #a6e22e">content</span>    <span style="color: #ffffff">:</span> <span style="color: #ffffff">Buffer</span><span style="color: #ffffff">,</span>
  <span style="color: #a6e22e">updated_at</span> <span style="color: #ffffff">:</span> <span style="color: #f6aa11">Date</span>
<span style="color: #ffffff">});</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>As you can see, the <code class="highlighter-rouge">content</code> field, which holds the actual TODO task, is of type <code class="highlighter-rouge">Buffer</code>, allowing it to support binary data. Like many Node.js apps, <code class="highlighter-rouge">snyk-demo-todo</code> also exposes a JSON API, which we will use to create an item from the command line:</p>

<div class="highlighter-rouge"><div class="syntax"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span style="color: #555555">> </span>curl http://localhost:3001/create --data <span style="color: #e6db74">'{"content":"Buy milk"}'</span> -H <span style="color: #e6db74">"Content-Type: application/json"</span>
<span style="color: #ffffff">QnV5IG1pbGs</span><span style="color: #f92672">=</span>%
</pre></td></tr></tbody></table>
</div>
</div>

<p>The value of the <code class="highlighter-rouge">content</code> variable was passed on to the <code class="highlighter-rouge">Buffer</code> constructor, initializing a short string that was then written to the DB. The new item is visible when we browse the application, and is also returned (base64 encoded) in the response:</p>

<div class="highlighter-rouge"><div class="syntax"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span style="color: #555555">> </span><span style="color: #f6aa11">echo</span> <span style="color: #e6db74">"QnV5IG1pbGs=%"</span> | base64 -D
Buy milk%
</pre></td></tr></tbody></table>
</div>
</div>

<p class="u--centered">
<img src="https://res.cloudinary.com/snyk/image/upload/v1458651899/blog-exploiting-buffer-todo-new-item.png" alt="" />
</p>

<p>Now to the vulnerability exploit. We’ll send the same request, but replace the <code class="highlighter-rouge">"Buy Milk"</code> string with a non-quoted <code class="highlighter-rouge">800</code> number:</p>

<div class="highlighter-rouge"><div class="syntax"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>curl http://localhost:3001/create --data <span style="color: #e6db74">'{"content":800}'</span> -H <span style="color: #e6db74">"Content-Type: application/json"</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Just like before, the value of <code class="highlighter-rouge">content</code> is passed to the <code class="highlighter-rouge">Buffer</code> constructor. However, this time the value is of type <code class="highlighter-rouge">number</code>, triggering the <em>other</em> <code class="highlighter-rouge">Buffer</code> constructor… This will initialize the TODO item with 800 bytes of uninitialized memory, stored into the DB. This data will again be visible in the HTML response (albeit binary so hard to read), and returned to our <code class="highlighter-rouge">curl</code> after base64 encoding:</p>

<div class="highlighter-rouge"><div class="syntax"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span style="color: #75715e"># Response to exploit CURL command</span>
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDKIAQEAAACQMogBAQAAAAAAAAAAAAAAcCKIAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAiiAEBAAAAMCOIAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAjiAEBAAAAAAAAAAAAAADwI4gBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8BeIAQEAAAAAAAAAAAAAAAAAAAAAAAAA0BaIAQEAAABQGIgBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+G6IAQEAAAC4AYkBAQAAACgCiQEBAAAAmAKJAQEAAACQA4kBAQAAAAAEiQEBAAAAcASJAQEAAADgBIkBAQAAAFAFiQEBAAAAwAWJAQEAAAAwBokBAQAAAKAGiQEBAAAAEAeJAQEAAACAB4kBAQAAAPAHiQEBAAAAYAiJAQEAAADQCIkBAQAAAEAJiQEBAAAAsAmJAQEAAAAgCokBAQAAAJAKiQEBAAAAAAuJAQEAAABwC4kBAQAAAOALiQEBAAAAUAyJAQEAAADADIkBAQAAADANiQEBAAAAAAAAAAAAAAADAAMAAAAAAIAaaQEBAAAAONEDAwEAAAAAAAAAAAAAADjSAwMBAAAAAgAAAAAAAAAYdQMDAQAAACgpagEBAAAACClqAQEAAAAAAAAAAAAAAMgpagEBAAAAkCpqAQEAAABwKmoBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAA
</pre></td></tr></tbody></table>
</div>
</div>

<p class="u--centered">
<img src="https://res.cloudinary.com/snyk/image/upload/v1458651899/blog-exploiting-buffer-todo-post-exploit.png" alt="" />
</p>

<p>We can now repeat this call over and over again to get more chunks of memory and base64 decode them. We will likely delete the created notes as we go to avoid suspicion, looking at the data or searching it for patterns like <code class="highlighter-rouge">secret</code>, <code class="highlighter-rouge">ssh-key</code>, source code and more.</p>

<h2 id="how-do-we-fix-it">How do we fix it?</h2>
<p>In our sample application, the vulnerability was inside the <code class="highlighter-rouge">mongoose</code> dependency. Their fix was to <a href="https://github.com/Automattic/mongoose/commit/2ff7d36c5e52270211b17f3a84c8a47c6f4d8c1f">convert numbers to arrays</a>, treating it as a single number instead of a length. If you’re using a <a href="https://snyk.io/vuln/npm:mongoose:20160116">vulnerable version of mongoose</a>, you should upgrade to a newer version. If you’re not sure if you’re using it, use <a href="https://snyk.io/docs/quick-start/">Snyk</a> to find and fix these and other vulnerabilities.</p>

<p>In case the vulnerability is in your own code, you can either disallow the use of the <code class="highlighter-rouge">number</code> constructor (optionally converting it to an array or string), or use the <code class="highlighter-rouge">fill(0)</code> function after each time its called. Note that zeroing memory, while efficient, does take some time for bigger buffers, so consider the performance impact this may have on your application.</p>

<h2 id="upcoming-changes-in-node-6">Upcoming Changes in Node 6</h2>
<p>This default behavior of <code class="highlighter-rouge">Buffer</code> is concerning, and the cause of <a href="https://snyk.io/vuln/npm:mongoose:20160116">multiple</a> <a href="https://snyk.io/vuln/npm:ws:20160104">known</a> <a href="https://snyk.io/vuln/npm:bittorrent-dht:20160104">vulnerabilities</a>, but changing it in current versions of Node is hard, as it could break applications. <a href="https://medium.com/@jasnell/node-js-buffer-api-changes-3c21f1048f97#.ok3tfcbye">As of Node 6</a>, however, you’re advised to use the explicit <code class="highlighter-rouge">alloc</code> and <code class="highlighter-rouge">allocUnsafe</code> methods, which will allocate space with and without zeroing respectively. This explicit API can help developers avoid similar mistakes.</p>

<p>The default constructor will still be supported and function the same, though it will be deprecated and discouraged. That said, you can choose to use the <code class="highlighter-rouge">--zero-fill-buffers</code> flag to Node (again, only as of Node 6), which will make the default <code class="highlighter-rouge">Buffer</code> number constructor zero-fill the allocated buffer.</p>

<h2 id="steps-to-stay-safe">5 Steps To Stay Safe</h2>
<p>Buffer is a useful but dangerous class. If you find yourself considering its use, considering the following:</p>

<ol>
  <li>Can you use a <code class="highlighter-rouge">TypedArray</code> or <code class="highlighter-rouge">ArrayBuffer</code> instead? These classes are also binary friendly, and zero-fill their memory.</li>
  <li>Can you disallow the <code class="highlighter-rouge">number</code> constructor? If so, do so, like <code class="highlighter-rouge">mongoose</code> did.</li>
  <li>Can you zero-fill the allocated data using <code class="highlighter-rouge">buf.fill(0)</code>? This will have a small performance impact, but be safer.</li>
  <li>If you absolutely cannot do all of the above, carefully track where the <code class="highlighter-rouge">Buffer</code> content goes. Very carefully.</li>
  <li>If you’re using npm packages in dependencies, run <a href="https://snyk.io/docs/#wizard">snyk wizard</a> to fix any <code class="highlighter-rouge">Buffer</code> related vulnerabilities your dependencies may have.</li>
</ol>